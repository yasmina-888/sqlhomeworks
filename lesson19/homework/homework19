Task 1: Create Employee Bonus Report

CREATE PROCEDURE GetEmployeeBonuses
AS
BEGIN
    CREATE TABLE #EmployeeBonus (
        EmployeeID INT,
        FullName NVARCHAR(101),
        Department NVARCHAR(50),
        Salary DECIMAL(10,2),
        BonusAmount DECIMAL(10,2)
    );

    INSERT INTO #EmployeeBonus (EmployeeID, FullName, Department, Salary, BonusAmount)
    SELECT 
        e.EmployeeID,
        CONCAT(e.FirstName, ' ', e.LastName),
        e.Department,
        e.Salary,
        e.Salary * b.BonusPercentage / 100.0
    FROM Employees e
    JOIN DepartmentBonus b ON e.Department = b.Department;

    SELECT * FROM #EmployeeBonus;
END;
 Task 2: Increase Salary by Department

CREATE PROCEDURE UpdateDepartmentSalaries
    @Dept NVARCHAR(50),
    @IncreasePercent DECIMAL(5,2)
AS
BEGIN
    UPDATE Employees
    SET Salary = Salary * (1 + @IncreasePercent / 100.0)
    WHERE Department = @Dept;

    SELECT * FROM Employees WHERE Department = @Dept;
END;
 Part 2: MERGE Tasks
 Task 3: Merge Products

MERGE Products_Current AS TARGET
USING Products_New AS SOURCE
ON TARGET.ProductID = SOURCE.ProductID

WHEN MATCHED THEN
    UPDATE SET 
        TARGET.ProductName = SOURCE.ProductName,
        TARGET.Price = SOURCE.Price

WHEN NOT MATCHED BY TARGET THEN
    INSERT (ProductID, ProductName, Price)
    VALUES (SOURCE.ProductID, SOURCE.ProductName, SOURCE.Price)

WHEN NOT MATCHED BY SOURCE THEN
    DELETE;

-- Return final state
SELECT * FROM Products_Current;
 Task 4: Tree Node Type Classification (LeetCode style)

SELECT 
    t1.id,
    CASE 
        WHEN t1.p_id IS NULL THEN 'Root'
        WHEN t1.id NOT IN (SELECT DISTINCT p_id FROM Tree WHERE p_id IS NOT NULL) THEN 'Leaf'
        ELSE 'Inner'
    END AS type
FROM Tree t1
ORDER BY t1.id;
 Task 5: Confirmation Rate (LeetCode style)

SELECT 
    s.user_id,
    ROUND(
        COALESCE(SUM(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END), 0) * 1.0 /
        COALESCE(COUNT(c.action), 0), 2
    ) AS confirmation_rate
FROM Signups s
LEFT JOIN Confirmations c ON s.user_id = c.user_id
GROUP BY s.user_id
ORDER BY s.user_id;
Task 6: Employees with Lowest Salary

SELECT * 
FROM employees 
WHERE salary = (
    SELECT MIN(salary) FROM employees
);
Task 7: Product Sales Summary Procedure

CREATE PROCEDURE GetProductSalesSummary
    @ProductID INT
AS
BEGIN
    SELECT 
        p.ProductName,
        SUM(s.Quantity) AS TotalQuantitySold,
        SUM(s.Quantity * p.Price) AS TotalSalesAmount,
        MIN(s.SaleDate) AS FirstSaleDate,
        MAX(s.SaleDate) AS LastSaleDate
    FROM Products p
    LEFT JOIN Sales s ON p.ProductID = s.ProductID
    WHERE p.ProductID = @ProductID
    GROUP BY p.ProductName
